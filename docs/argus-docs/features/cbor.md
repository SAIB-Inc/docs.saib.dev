---
title: CBOR Deserialization
sidebar_label: CBOR Deserialization
sidebar_position: 4
---

It is important for indexers to convert data between CBOR and C# types. Since Argus is powered by Chrysalis, it leverages a robust CBOR serialization library. However, deserialized blocks do not automatically yield domain-specific data—Argus is generic and doesn’t know your smart contract types. You must define your own types and annotations.

This guide touches on the basics of `Chrysalis.Cbor`. For more detail, see the Chrysalis.Cbor documentation.

## Defining a Datum Type

Imagine you’re indexing SundaeSwap liquidity pool data. The on-chain Aiken type for a pool datum looks like:

```rust
pub type PoolDatum {
  identifier: Ident,
  assets: (AssetClass, AssetClass),
  circulating_lp: Int,
  bid_fees_per_10_thousand: Int,
  ask_fees_per_10_thousand: Int,
  fee_manager: Option<multisig.MultisigScript>,
  market_open: Int,
  protocol_fees: Int,
}
```

To map this into C#, use record types with CBOR attributes:

```csharp
using Chrysalis.Cbor.Serialization.Attributes;
using Chrysalis.Cbor.Types;

namespace Argus.Sync.Example.Models.Datums;

[CborSerializable]
[CborConstr(0)]
public partial record SundaeSwapLiquidityPoolDatum(
    [CborOrder(0)] byte[] Identifier,
    [CborOrder(1)] AssetClassTuple Assets,
    [CborOrder(2)] ulong CirculatingLp,
    [CborOrder(3)] ulong BidFeesPer10Thousand,
    [CborOrder(4)] ulong AskFeesPer10Thousand,
    [CborOrder(5)] Option<MultisigScript> FeeManager,
    [CborOrder(6)] ulong MarketOpen,
    [CborOrder(7)] ulong ProtocolFees
) : CborBase;
```

## Using Your Datum in `RollForwardAsync`

Within your reducer, detect and deserialize inline datum values:

```csharp
public async Task RollForwardAsync(Block block)
{
    ulong slot = block.Header().HeaderBody().Slot();
    using var dbContext = dbContextFactory.CreateDbContext();

    foreach (var tx in block.Body().TransactionBodies())
    {
        string txHash = tx.Hash();
        var outputs = tx.Outputs().ToList();

        for (int idx = 0; idx < outputs.Count; idx++)
        {
            var output = outputs[idx];
            if (TryDeserializeDatum(output, out SundaeSwapLiquidityPoolDatum datum))
            {
                string outRef = $"{txHash}#{idx}";
                var pool = ParseLiquidityPool(datum) with
                {
                    Slot = slot,
                    Outref = outRef,
                    TxOutputRaw = output.Raw?.ToArray()!
                };

                dbContext.SundaeSwapLiquidityPools.Add(pool);
            }
        }
    }

    await dbContext.SaveChangesAsync();
}

private bool TryDeserializeDatum(TransactionOutput txOut, out SundaeSwapLiquidityPoolDatum datum)
{
    datum = default!;
    try
    {
        // Only process UTxOs for your script
        var address = new WalletAddress(txOut.Address());
        var keyHash = address.GetPaymentKeyHash() ?? Array.Empty<byte>();
        if (Convert.ToHexString(keyHash).ToLowerInvariant() != _scriptHash)
            return false;

        var datumOption = txOut.DatumOption();
        if (datumOption is null)
            return false;

        var inlineDatum = new CborEncodedValue(datumOption.Data());
        // Deserialize using autogenerated reader
        datum = SundaeSwapLiquidityPoolDatum.Read(inlineDatum.GetValue());
        // Or via serializer:
        // datum = CborSerializer.Deserialize<SundaeSwapLiquidityPoolDatum>(inlineDatum.GetValue());
        return datum is not null;
    }
    catch
    {
        return false;
    }
}
```

Once deserialized, you can access fields on `SundaeSwapLiquidityPoolDatum` like any other C# object, without manual handling of raw CBOR.
